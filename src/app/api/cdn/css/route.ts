import { NextRequest, NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';

export async function GET(request: NextRequest) {
    const searchParams = request.nextUrl.searchParams;
    const family = searchParams.get('family');

    if (!family) {
        return new NextResponse('Family not specified', { status: 400 });
    }

    const fontDir = path.join(process.cwd(), 'fonts', family);

    if (!fs.existsSync(fontDir)) {
        return new NextResponse('Font family not found', { status: 404 });
    }

    try {
        const files = fs.readdirSync(fontDir);
        const fontFiles = files.filter(f =>
            f.endsWith('.ttf') || f.endsWith('.woff') || f.endsWith('.woff2') || f.endsWith('.otf')
        );

        let css = `/* Generated by Webfont CDN */\n\n`;

        // Helper to determine weight/style from filename
        // e.g., MyFont-BoldItalic.ttf -> weight: 700, style: italic
        const parseFile = (filename: string) => {
            const lower = filename.toLowerCase();
            let weight = 400;
            let style = 'normal';

            if (lower.includes('thin') || lower.includes('100')) weight = 100;
            else if (lower.includes('extralight') || lower.includes('200')) weight = 200;
            else if (lower.includes('light') || lower.includes('300')) weight = 300;
            else if (lower.includes('medium') || lower.includes('500')) weight = 500;
            else if (lower.includes('semibold') || lower.includes('600')) weight = 600;
            else if (lower.includes('bold') || lower.includes('700')) weight = 700;
            else if (lower.includes('extrabold') || lower.includes('800')) weight = 800;
            else if (lower.includes('black') || lower.includes('900')) weight = 900;

            if (lower.includes('italic')) style = 'italic';

            const ext = path.extname(filename).substring(1); // ttf, woff2
            const format = ext === 'ttf' ? 'truetype' : ext === 'otf' ? 'opentype' : ext;

            return { weight, style, format };
        };

        // If actual font.css exists, append it first or use it? 
        // User said "generate automatically", so we prioritize generation, 
        // but maybe respecting manual overrides is nice. 
        // For now, let's purely generate to satisfy "just put ttf file here".

        fontFiles.forEach(file => {
            const info = parseFile(file);
            // Use the family name from directory as the font-family
            // Clean it up if needed, e.g. "my-font" -> "My Font" if desired, 
            // but usually keeping slug is safer or using a formatted name.
            // Let's use the raw directory name for consistency with the URL, 
            // or try to prettify it. Ideally we pass a name query param or derive from slug.
            // Standard practice: use the directory name as the family name.

            // Construct absolute URL or relative?
            // CSS is served from /fonts/:family/font.css
            // Font files are at /fonts/:family/:file
            // So relative path "./:file" works perfectly! 
            // Or simply ":file" since they are in the same "virtual" directory.

            css += `@font-face {
  font-family: '${family}';
  src: url('${file}') format('${info.format}');
  font-weight: ${info.weight};
  font-style: ${info.style};
  font-display: swap;
}\n\n`;
        });

        return new NextResponse(css, {
            headers: {
                'Content-Type': 'text/css',
                'Cache-Control': 'public, max-age=31536000, immutable',
            },
        });

    } catch (error) {
        console.error('CSS Gen Error:', error);
        return new NextResponse('Internal Server Error', { status: 500 });
    }
}
